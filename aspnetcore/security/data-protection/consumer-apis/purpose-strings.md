---
title: Cadenas de propósito en ASP.NET Core
author: rick-anderson
description: Obtenga información acerca de cómo se utilizan cadenas de propósito en las API de protección de datos de ASP.NET Core.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 4c85423f8de7e4b784ae1bb304a884541df251b6
ms.sourcegitcommit: a1afd04758e663d7062a5bfa8a0d4dca38f42afc
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 06/20/2018
ms.locfileid: "36278770"
---
# <a name="purpose-strings-in-aspnet-core"></a><span data-ttu-id="7c34e-103">Cadenas de propósito en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="7c34e-103">Purpose strings in ASP.NET Core</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="7c34e-104">Componentes que consumen `IDataProtectionProvider` debe pasar un único *fines* parámetro para el `CreateProtector` método.</span><span class="sxs-lookup"><span data-stu-id="7c34e-104">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="7c34e-105">Los fines *parámetro* es inherente a la seguridad del sistema de protección de datos, ya que proporciona aislamiento entre los consumidores de cifrado, incluso si las claves criptográficas de raíz son los mismos.</span><span class="sxs-lookup"><span data-stu-id="7c34e-105">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="7c34e-106">Cuando un consumidor especifica un propósito, la cadena de fin se usa junto con las claves criptográficas de raíz para derivar criptográficas subclaves únicas para ese consumidor.</span><span class="sxs-lookup"><span data-stu-id="7c34e-106">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="7c34e-107">Esto permite aislar el consumidor de todos los otros consumidores de cifrado en la aplicación: ningún otro componente puede leer sus cargas y no se puede leer cargas de cualquier otro componente.</span><span class="sxs-lookup"><span data-stu-id="7c34e-107">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="7c34e-108">Este aislamiento también presenta factible todas las categorías de un ataque contra el componente.</span><span class="sxs-lookup"><span data-stu-id="7c34e-108">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Ejemplo de diagrama de propósito](purpose-strings/_static/purposes.png)

<span data-ttu-id="7c34e-110">En el diagrama anterior, `IDataProtector` instancias A y B **no** leer de todas las demás cargas, solo sus propios.</span><span class="sxs-lookup"><span data-stu-id="7c34e-110">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="7c34e-111">La cadena de fin no tiene que ser secreto.</span><span class="sxs-lookup"><span data-stu-id="7c34e-111">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="7c34e-112">Simplemente debe ser único en el sentido de que ningún otro componente con buen comportamiento nunca proporcione la misma cadena de fin.</span><span class="sxs-lookup"><span data-stu-id="7c34e-112">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="7c34e-113">Con el nombre de espacio de nombres y el tipo del componente consumir las API de protección de datos es una buena regla general, al igual que en la práctica que esta información nunca estará en conflicto.</span><span class="sxs-lookup"><span data-stu-id="7c34e-113">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="7c34e-114">Un componente creado por Contoso que es responsable de minting tokens de portador puede usar Contoso.Security.BearerToken como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="7c34e-114">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="7c34e-115">O - incluso mejor -, podría usar Contoso.Security.BearerToken.v1 como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="7c34e-115">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="7c34e-116">Anexar el número de versión permite que una versión futura usar Contoso.Security.BearerToken.v2 como su propósito, y las distintas versiones sería completamente aisladas entre sí como ir de cargas.</span><span class="sxs-lookup"><span data-stu-id="7c34e-116">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="7c34e-117">Desde el parámetro de fines `CreateProtector` es una matriz de cadenas, los pasos anteriores se haya en su lugar especificados como `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="7c34e-117">Since the purposes parameter to `CreateProtector` is a string array, the above could've been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="7c34e-118">Esto permite establecer una jerarquía de propósitos y se abre la posibilidad de escenarios de varios inquilinos con el sistema de protección de datos.</span><span class="sxs-lookup"><span data-stu-id="7c34e-118">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="7c34e-119">Componentes no deben permitir proporcionados por el usuario de confianza como el único origen de entrada de la cadena con fines.</span><span class="sxs-lookup"><span data-stu-id="7c34e-119">Components shouldn't allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="7c34e-120">Por ejemplo, considere la posibilidad de un componente Contoso.Messaging.SecureMessage que es responsable de almacenar mensajes seguros.</span><span class="sxs-lookup"><span data-stu-id="7c34e-120">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="7c34e-121">Si el componente de mensajería seguro llamase a `CreateProtector([ username ])`, a continuación, un usuario malintencionado podría crear una cuenta con el nombre de usuario "Contoso.Security.BearerToken" en un intento de obtener el componente para llamar a `CreateProtector([ "Contoso.Security.BearerToken" ])`, lo que sin darse cuenta y la mensajería segura sistema que lleva cargas que se puede percibir como tokens de autenticación.</span><span class="sxs-lookup"><span data-stu-id="7c34e-121">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="7c34e-122">Una cadena con fines mejor para el componente de mensajería sería `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, lo que proporciona aislamiento adecuado.</span><span class="sxs-lookup"><span data-stu-id="7c34e-122">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="7c34e-123">El aislamiento que ofrecen y los comportamientos de `IDataProtectionProvider`, `IDataProtector`, y con fines de son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="7c34e-123">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="7c34e-124">Para un determinado `IDataProtectionProvider` objeto, el `CreateProtector` método creará una `IDataProtector` objeto ligada a ambos en modo exclusivo la `IDataProtectionProvider` objeto que lo creó y el parámetro de propósitos que se pasó al método.</span><span class="sxs-lookup"><span data-stu-id="7c34e-124">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="7c34e-125">El parámetro de fin no debe ser null.</span><span class="sxs-lookup"><span data-stu-id="7c34e-125">The purpose parameter must not be null.</span></span> <span data-ttu-id="7c34e-126">(Si no se especifica con fines como una matriz, esto significa que la matriz no debe ser de longitud cero y todos los elementos de la matriz deben ser distinto de null). Un propósito de una cadena vacía es técnicamente válido pero en absoluto.</span><span class="sxs-lookup"><span data-stu-id="7c34e-126">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="7c34e-127">Argumentos de dos objetivos son equivalentes si y solo si contienen las mismas cadenas (usando a un comparador ordinal) en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="7c34e-127">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="7c34e-128">Un argumento único propósito es equivalente a la matriz con fines de solo elemento correspondiente.</span><span class="sxs-lookup"><span data-stu-id="7c34e-128">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="7c34e-129">Dos `IDataProtector` objetos son equivalentes si y solo si se crean desde equivalente `IDataProtectionProvider` objetos con los parámetros de fines equivalente.</span><span class="sxs-lookup"><span data-stu-id="7c34e-129">Two `IDataProtector` objects are equivalent if and only if they're created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="7c34e-130">Para un determinado `IDataProtector` (objeto), una llamada a `Unprotect(protectedData)` devolverá el original `unprotectedData` si y solo si `protectedData := Protect(unprotectedData)` para un equivalente `IDataProtector` objeto.</span><span class="sxs-lookup"><span data-stu-id="7c34e-130">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="7c34e-131">No estamos pensando en el caso de que algún componente intencionadamente elige una cadena de propósito que se sabe que entran en conflicto con otro componente.</span><span class="sxs-lookup"><span data-stu-id="7c34e-131">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="7c34e-132">Esos componentes básicamente se consideraría malintencionado, y este sistema no está diseñado para proporcionar garantías de seguridad en caso de que código malintencionado ya se está ejecutando dentro del proceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="7c34e-132">Such a component would essentially be considered malicious, and this system isn't intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
