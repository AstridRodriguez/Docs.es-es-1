---
title: "Cadenas de propósito"
author: rick-anderson
description: "Este documento describe cómo se utilizan cadenas de propósito de la API de protección de datos de ASP.NET Core."
keywords: "ASP.NET Core, protección de datos, cadenas de propósito"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: c96ed361-c382-4980-8933-800e740cfc38
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/consumer-apis/purpose-strings
ms.openlocfilehash: 0d759937703d2a25604042b5e74e71155d635c1b
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/10/2017
---
# <a name="purpose-strings"></a><span data-ttu-id="88493-104">Cadenas de propósito</span><span class="sxs-lookup"><span data-stu-id="88493-104">Purpose Strings</span></span>

<a name="data-protection-consumer-apis-purposes"></a>

<span data-ttu-id="88493-105">Componentes que consumen `IDataProtectionProvider` debe pasar un único *fines* parámetro para el `CreateProtector` método.</span><span class="sxs-lookup"><span data-stu-id="88493-105">Components which consume `IDataProtectionProvider` must pass a unique *purposes* parameter to the `CreateProtector` method.</span></span> <span data-ttu-id="88493-106">Los fines *parámetro* es inherente a la seguridad del sistema de protección de datos, ya que proporciona aislamiento entre los consumidores de cifrado, incluso si las claves criptográficas de raíz son los mismos.</span><span class="sxs-lookup"><span data-stu-id="88493-106">The purposes *parameter* is inherent to the security of the data protection system, as it provides isolation between cryptographic consumers, even if the root cryptographic keys are the same.</span></span>

<span data-ttu-id="88493-107">Cuando un consumidor especifica un propósito, la cadena de fin se usa junto con las claves criptográficas de raíz para derivar criptográficas subclaves únicas para ese consumidor.</span><span class="sxs-lookup"><span data-stu-id="88493-107">When a consumer specifies a purpose, the purpose string is used along with the root cryptographic keys to derive cryptographic subkeys unique to that consumer.</span></span> <span data-ttu-id="88493-108">Esto permite aislar el consumidor de todos los otros consumidores de cifrado en la aplicación: ningún otro componente puede leer sus cargas y no se puede leer cargas de cualquier otro componente.</span><span class="sxs-lookup"><span data-stu-id="88493-108">This isolates the consumer from all other cryptographic consumers in the application: no other component can read its payloads, and it cannot read any other component's payloads.</span></span> <span data-ttu-id="88493-109">Este aislamiento también presenta factible todas las categorías de un ataque contra el componente.</span><span class="sxs-lookup"><span data-stu-id="88493-109">This isolation also renders infeasible entire categories of attack against the component.</span></span>

![Ejemplo de diagrama de propósito](purpose-strings/_static/purposes.png)

<span data-ttu-id="88493-111">En el diagrama anterior, `IDataProtector` instancias A y B **no** leer de todas las demás cargas, solo sus propios.</span><span class="sxs-lookup"><span data-stu-id="88493-111">In the diagram above, `IDataProtector` instances A and B **cannot** read each other's payloads, only their own.</span></span>

<span data-ttu-id="88493-112">La cadena de fin no tiene que ser secreto.</span><span class="sxs-lookup"><span data-stu-id="88493-112">The purpose string doesn't have to be secret.</span></span> <span data-ttu-id="88493-113">Simplemente debe ser único en el sentido de que ningún otro componente con buen comportamiento nunca proporcione la misma cadena de fin.</span><span class="sxs-lookup"><span data-stu-id="88493-113">It should simply be unique in the sense that no other well-behaved component will ever provide the same purpose string.</span></span>

>[!TIP]
> <span data-ttu-id="88493-114">Con el nombre de espacio de nombres y el tipo del componente consumir las API de protección de datos es una buena regla general, al igual que en la práctica que esta información nunca estará en conflicto.</span><span class="sxs-lookup"><span data-stu-id="88493-114">Using the namespace and type name of the component consuming the data protection APIs is a good rule of thumb, as in practice this information will never conflict.</span></span>
>
><span data-ttu-id="88493-115">Un componente creado por Contoso que es responsable de minting tokens de portador puede usar Contoso.Security.BearerToken como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="88493-115">A Contoso-authored component which is responsible for minting bearer tokens might use Contoso.Security.BearerToken as its purpose string.</span></span> <span data-ttu-id="88493-116">O - incluso mejor -, podría usar Contoso.Security.BearerToken.v1 como cadena de su propósito.</span><span class="sxs-lookup"><span data-stu-id="88493-116">Or - even better - it might use Contoso.Security.BearerToken.v1 as its purpose string.</span></span> <span data-ttu-id="88493-117">Anexar el número de versión permite que una versión futura usar Contoso.Security.BearerToken.v2 como su propósito, y las distintas versiones sería completamente aisladas entre sí como ir de cargas.</span><span class="sxs-lookup"><span data-stu-id="88493-117">Appending the version number allows a future version to use Contoso.Security.BearerToken.v2 as its purpose, and the different versions would be completely isolated from one another as far as payloads go.</span></span>

<span data-ttu-id="88493-118">Desde el parámetro de fines `CreateProtector` es una matriz de cadenas, los pasos anteriores podrían se hayan en su lugar especificados como `[ "Contoso.Security.BearerToken", "v1" ]`.</span><span class="sxs-lookup"><span data-stu-id="88493-118">Since the purposes parameter to `CreateProtector` is a string array, the above could have been instead specified as `[ "Contoso.Security.BearerToken", "v1" ]`.</span></span> <span data-ttu-id="88493-119">Esto permite establecer una jerarquía de propósitos y se abre la posibilidad de escenarios de varios inquilinos con el sistema de protección de datos.</span><span class="sxs-lookup"><span data-stu-id="88493-119">This allows establishing a hierarchy of purposes and opens up the possibility of multi-tenancy scenarios with the data protection system.</span></span>

<a name="data-protection-contoso-purpose"></a>

>[!WARNING]
> <span data-ttu-id="88493-120">Componentes no deben permitir proporcionados por el usuario de confianza como el único origen de entrada de la cadena con fines.</span><span class="sxs-lookup"><span data-stu-id="88493-120">Components should not allow untrusted user input to be the sole source of input for the purposes chain.</span></span>
>
><span data-ttu-id="88493-121">Por ejemplo, considere la posibilidad de un componente Contoso.Messaging.SecureMessage que es responsable de almacenar mensajes seguros.</span><span class="sxs-lookup"><span data-stu-id="88493-121">For example, consider a component Contoso.Messaging.SecureMessage which is responsible for storing secure messages.</span></span> <span data-ttu-id="88493-122">Si el componente de mensajería seguro llamase a `CreateProtector([ username ])`, a continuación, un usuario malintencionado podría crear una cuenta con el nombre de usuario "Contoso.Security.BearerToken" en un intento de obtener el componente para llamar a `CreateProtector([ "Contoso.Security.BearerToken" ])`, lo que sin darse cuenta y la mensajería segura sistema que lleva cargas que se puede percibir como tokens de autenticación.</span><span class="sxs-lookup"><span data-stu-id="88493-122">If the secure messaging component were to call `CreateProtector([ username ])`, then a malicious user might create an account with username "Contoso.Security.BearerToken" in an attempt to get the component to call `CreateProtector([ "Contoso.Security.BearerToken" ])`, thus inadvertently causing the secure messaging system to mint payloads that could be perceived as authentication tokens.</span></span>
>
><span data-ttu-id="88493-123">Una cadena con fines mejor para el componente de mensajería sería `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, lo que proporciona aislamiento adecuado.</span><span class="sxs-lookup"><span data-stu-id="88493-123">A better purposes chain for the messaging component would be `CreateProtector([ "Contoso.Messaging.SecureMessage", "User: username" ])`, which provides proper isolation.</span></span>

<span data-ttu-id="88493-124">El aislamiento que ofrecen y los comportamientos de `IDataProtectionProvider`, `IDataProtector`, y con fines de son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="88493-124">The isolation provided by and behaviors of `IDataProtectionProvider`, `IDataProtector`, and purposes are as follows:</span></span>

* <span data-ttu-id="88493-125">Para un determinado `IDataProtectionProvider` objeto, el `CreateProtector` método creará una `IDataProtector` objeto ligada a ambos en modo exclusivo la `IDataProtectionProvider` objeto que lo creó y el parámetro de propósitos que se pasó al método.</span><span class="sxs-lookup"><span data-stu-id="88493-125">For a given `IDataProtectionProvider` object, the `CreateProtector` method will create an `IDataProtector` object uniquely tied to both the `IDataProtectionProvider` object which created it and the purposes parameter which was passed into the method.</span></span>

* <span data-ttu-id="88493-126">El parámetro de fin no debe ser null.</span><span class="sxs-lookup"><span data-stu-id="88493-126">The purpose parameter must not be null.</span></span> <span data-ttu-id="88493-127">(Si no se especifica con fines como una matriz, esto significa que la matriz no debe ser de longitud cero y todos los elementos de la matriz deben ser distinto de null). Un propósito de una cadena vacía es técnicamente válido pero en absoluto.</span><span class="sxs-lookup"><span data-stu-id="88493-127">(If purposes is specified as an array, this means that the array must not be of zero length and all elements of the array must be non-null.) An empty string purpose is technically allowed but is discouraged.</span></span>

* <span data-ttu-id="88493-128">Argumentos de dos objetivos son equivalentes si y solo si contienen las mismas cadenas (usando a un comparador ordinal) en el mismo orden.</span><span class="sxs-lookup"><span data-stu-id="88493-128">Two purposes arguments are equivalent if and only if they contain the same strings (using an ordinal comparer) in the same order.</span></span> <span data-ttu-id="88493-129">Un argumento único propósito es equivalente a la matriz con fines de solo elemento correspondiente.</span><span class="sxs-lookup"><span data-stu-id="88493-129">A single purpose argument is equivalent to the corresponding single-element purposes array.</span></span>

* <span data-ttu-id="88493-130">Dos `IDataProtector` objetos son equivalentes si y solo si se crean a partir de la equivalencia `IDataProtectionProvider` objetos con los parámetros de fines equivalente.</span><span class="sxs-lookup"><span data-stu-id="88493-130">Two `IDataProtector` objects are equivalent if and only if they are created from equivalent `IDataProtectionProvider` objects with equivalent purposes parameters.</span></span>

* <span data-ttu-id="88493-131">Para un determinado `IDataProtector` (objeto), una llamada a `Unprotect(protectedData)` devolverá el original `unprotectedData` si y solo si `protectedData := Protect(unprotectedData)` para un equivalente `IDataProtector` objeto.</span><span class="sxs-lookup"><span data-stu-id="88493-131">For a given `IDataProtector` object, a call to `Unprotect(protectedData)` will return the original `unprotectedData` if and only if `protectedData := Protect(unprotectedData)` for an equivalent `IDataProtector` object.</span></span>

> [!NOTE]
> <span data-ttu-id="88493-132">No estamos pensando en el caso de que algún componente intencionadamente elige una cadena de propósito que se sabe que entran en conflicto con otro componente.</span><span class="sxs-lookup"><span data-stu-id="88493-132">We're not considering the case where some component intentionally chooses a purpose string which is known to conflict with another component.</span></span> <span data-ttu-id="88493-133">Esos componentes básicamente se consideraría malintencionado, y este sistema no está diseñado para proporcionar garantías de seguridad en caso de que código malintencionado ya se está ejecutando dentro del proceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="88493-133">Such a component would essentially be considered malicious, and this system is not intended to provide security guarantees in the event that malicious code is already running inside of the worker process.</span></span>
