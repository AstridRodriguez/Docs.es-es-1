---
title: Probar la lógica del controlador en ASP.NET Core
author: ardalis
description: Obtenga información sobre cómo probar la lógica del controlador en ASP.NET Core con Moq y xUnit.
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/testing
ms.openlocfilehash: a0073e4de361c37a6854ceaf54ffd9eaea4837d4
ms.sourcegitcommit: 43bd79667bbdc8a07bd39fb4cd6f7ad3e70212fb
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/04/2018
ms.locfileid: "34567054"
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="2fefd-103">Probar la lógica del controlador en ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="2fefd-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="2fefd-104">Por [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="2fefd-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="2fefd-105">Los controladores de las aplicaciones ASP.NET MVC deben ser de tamaño reducido e ir enfocados a abordar problemas de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="2fefd-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="2fefd-106">Los controladores de gran tamaño que tratan problemas no relacionados con la interfaz de usuario son bastante más difíciles de probar y mantener.</span><span class="sxs-lookup"><span data-stu-id="2fefd-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="2fefd-107">Ver o descargar el ejemplo desde GitHub</span><span class="sxs-lookup"><span data-stu-id="2fefd-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="2fefd-108">Probar los controladores</span><span class="sxs-lookup"><span data-stu-id="2fefd-108">Testing controllers</span></span>

<span data-ttu-id="2fefd-109">Los controladores son una parte fundamental de cualquier aplicación ASP.NET Core MVC.</span><span class="sxs-lookup"><span data-stu-id="2fefd-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="2fefd-110">Por tanto, debe tener la seguridad de que se comportan según lo previsto en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="2fefd-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="2fefd-111">Las pruebas automatizadas pueden darle esta seguridad, así como detectar errores antes de que lleguen a la fase producción.</span><span class="sxs-lookup"><span data-stu-id="2fefd-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="2fefd-112">Es importante no asignar responsabilidades innecesarias a los controladores y procurar que las pruebas se centran únicamente en las responsabilidades del controlador.</span><span class="sxs-lookup"><span data-stu-id="2fefd-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="2fefd-113">La lógica de controlador debería ser mínima y no ir enfocada a cuestiones de infraestructura o lógica empresarial (por ejemplo, el acceso a datos).</span><span class="sxs-lookup"><span data-stu-id="2fefd-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="2fefd-114">Compruebe la lógica del controlador, no el marco.</span><span class="sxs-lookup"><span data-stu-id="2fefd-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="2fefd-115">Compruebe el *comportamiento* del controlador en función de las entradas válidas o no válidas.</span><span class="sxs-lookup"><span data-stu-id="2fefd-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="2fefd-116">Compruebe las respuestas de controlador según el resultado de la operación empresarial que realiza.</span><span class="sxs-lookup"><span data-stu-id="2fefd-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="2fefd-117">Estas son algunas de las responsabilidades habituales de los controladores:</span><span class="sxs-lookup"><span data-stu-id="2fefd-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="2fefd-118">Comprobar `ModelState.IsValid`</span><span class="sxs-lookup"><span data-stu-id="2fefd-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="2fefd-119">Devolver una respuesta de error si `ModelState` no es válido</span><span class="sxs-lookup"><span data-stu-id="2fefd-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="2fefd-120">Recuperar una entidad de negocio de la persistencia</span><span class="sxs-lookup"><span data-stu-id="2fefd-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="2fefd-121">Llevar a cabo una acción en la entidad empresarial</span><span class="sxs-lookup"><span data-stu-id="2fefd-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="2fefd-122">Guardar la entidad comercial para persistencia</span><span class="sxs-lookup"><span data-stu-id="2fefd-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="2fefd-123">Devolver un `IActionResult` apropiado</span><span class="sxs-lookup"><span data-stu-id="2fefd-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="2fefd-124">Pruebas unitarias</span><span class="sxs-lookup"><span data-stu-id="2fefd-124">Unit testing</span></span>

<span data-ttu-id="2fefd-125">Las [pruebas unitarias](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) conllevan probar una parte de una aplicación de forma aislada con respecto a su infraestructura y dependencias.</span><span class="sxs-lookup"><span data-stu-id="2fefd-125">[Unit testing](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="2fefd-126">Cuando se realizan pruebas unitarias de la lógica de controlador, solo se comprueba el contenido de una única acción, no el comportamiento de sus dependencias o del marco en sí.</span><span class="sxs-lookup"><span data-stu-id="2fefd-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="2fefd-127">Cuando realice pruebas unitarias de sus acciones de controlador, asegúrese de que solo se centran en el comportamiento.</span><span class="sxs-lookup"><span data-stu-id="2fefd-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="2fefd-128">Una prueba unitaria de controlador evita tener que recurrir a elementos como los [filtros](filters.md), el [enrutamiento](../../fundamentals/routing.md) o el [enlace de modelos](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="2fefd-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="2fefd-129">Al centrarse en comprobar solo una cosa, las pruebas unitarias suelen ser fáciles de escribir y rápidas de ejecutar.</span><span class="sxs-lookup"><span data-stu-id="2fefd-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="2fefd-130">Un conjunto de pruebas unitarias bien escrito se puede ejecutar con frecuencia sin demasiada sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="2fefd-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="2fefd-131">Pero las pruebas unitarias no detectan problemas de interacción entre componentes, que es el propósito de las [pruebas de integración](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="2fefd-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="2fefd-132">Si está escribiendo filtros personalizados, rutas, etc., debería realizar pruebas unitarias en ellos, pero no como parte de las comprobaciones de una acción de controlador determinada,</span><span class="sxs-lookup"><span data-stu-id="2fefd-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="2fefd-133">sino de forma aislada.</span><span class="sxs-lookup"><span data-stu-id="2fefd-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="2fefd-134">[Cree y ejecute pruebas unitarias con Visual Studio](/visualstudio/test/unit-test-your-code).</span><span class="sxs-lookup"><span data-stu-id="2fefd-134">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="2fefd-135">Para explicar las pruebas unitarias, revisaremos el siguiente controlador.</span><span class="sxs-lookup"><span data-stu-id="2fefd-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="2fefd-136">Muestra una lista de sesiones de lluvia de ideas y permite crear nuevas sesiones de lluvia de ideas con un método POST:</span><span class="sxs-lookup"><span data-stu-id="2fefd-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="2fefd-137">El controlador sigue el [principio de dependencias explícitas](http://deviq.com/explicit-dependencies-principle/), de modo que espera que la inserción de dependencias le proporcione una instancia de `IBrainstormSessionRepository`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="2fefd-138">Esto es bastante sencillo de comprobar si se usa un marco de objeto ficticio, como [Moq](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="2fefd-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="2fefd-139">El método `HTTP GET Index` no tiene bucles ni bifurcaciones y solamente llama a un método.</span><span class="sxs-lookup"><span data-stu-id="2fefd-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="2fefd-140">Para probar este método `Index`, tenemos que confirmar que se devuelve un `ViewResult`, con un `ViewModel` del método `List` del repositorio.</span><span class="sxs-lookup"><span data-stu-id="2fefd-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="2fefd-141">El método `HomeController` `HTTP POST Index` (mostrado arriba) debe comprobar lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="2fefd-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="2fefd-142">El método de acción devuelve un `ViewResult` de solicitud incorrecta con los datos adecuados cuando `ModelState.IsValid` es `false`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="2fefd-143">Se llama al método `Add` en el repositorio y se devuelve un `RedirectToActionResult` con los argumentos correctos cuando `ModelState.IsValid` es true.</span><span class="sxs-lookup"><span data-stu-id="2fefd-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="2fefd-144">El estado de modelo no válido se puede comprobar introduciendo errores con `AddModelError`, como se muestra en la primera prueba de abajo.</span><span class="sxs-lookup"><span data-stu-id="2fefd-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="2fefd-145">La primera prueba confirma cuándo `ModelState` no es válido; se devuelve el mismo `ViewResult` que para una solicitud `GET`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="2fefd-146">Cabe decir que la prueba no intenta pasar un modelo no válido.</span><span class="sxs-lookup"><span data-stu-id="2fefd-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="2fefd-147">Eso no funcionaría de todas formas, ya que el enlace de modelos no se está ejecutando (aunque una [prueba de integración](xref:mvc/controllers/testing#integration-testing) sí usaría el enlace de modelos).</span><span class="sxs-lookup"><span data-stu-id="2fefd-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="2fefd-148">En este caso concreto no estamos comprobando el enlace de modelos.</span><span class="sxs-lookup"><span data-stu-id="2fefd-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="2fefd-149">Con estas pruebas unitarias solamente estamos comprobando lo que el código del método de acción hace.</span><span class="sxs-lookup"><span data-stu-id="2fefd-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="2fefd-150">La segunda prueba comprueba si, cuando `ModelState` es válido, se agrega un nuevo `BrainstormSession` (a través del repositorio) y el método devuelve un `RedirectToActionResult` con las propiedades que se esperan.</span><span class="sxs-lookup"><span data-stu-id="2fefd-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="2fefd-151">Las llamadas ficticias que no se efectúan se suelen omitir, aunque llamar a `Verifiable` al final de la llamada nos permite confirmar esto en la prueba.</span><span class="sxs-lookup"><span data-stu-id="2fefd-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="2fefd-152">Esto se logra con una llamada a `mockRepo.Verify`, que producirá un error en la prueba si no se ha llamado al método esperado.</span><span class="sxs-lookup"><span data-stu-id="2fefd-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="2fefd-153">La biblioteca Moq usada en este ejemplo nos permite mezclar fácilmente objetos ficticios comprobables (o "estrictos") con objetos ficticios no comprobables (también denominados "flexibles" o stub).</span><span class="sxs-lookup"><span data-stu-id="2fefd-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="2fefd-154">Obtenga más información sobre cómo [personalizar el comportamiento de objetos ficticios con Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="2fefd-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="2fefd-155">Otro controlador de la aplicación muestra información relacionada con una sesión de lluvia de ideas determinada.</span><span class="sxs-lookup"><span data-stu-id="2fefd-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="2fefd-156">Este controlador incluye lógica para tratar los valores de identificador no válidos:</span><span class="sxs-lookup"><span data-stu-id="2fefd-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="2fefd-157">La acción de controlador tiene tres casos que comprobar, uno por cada instrucción `return`:</span><span class="sxs-lookup"><span data-stu-id="2fefd-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="2fefd-158">La aplicación expone la funcionalidad como una API web (una lista de ideas asociadas a una sesión de lluvia de ideas y un método para agregar nuevas ideas a una sesión):</span><span class="sxs-lookup"><span data-stu-id="2fefd-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="2fefd-159">El método `ForSession` devuelve una lista de tipos de `IdeaDTO`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="2fefd-160">Evite devolver entidades de dominio de empresa directamente a través de llamadas API, ya que con frecuencia incluyen más datos de los que el cliente de API requiere y asocian innecesariamente el modelo de dominio interno de su aplicación con la API que se expone externamente.</span><span class="sxs-lookup"><span data-stu-id="2fefd-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="2fefd-161">La asignación entre las entidades de dominio y los tipos que se van a devolver se puede realizar manualmente (usando un método `Select` de LINQ, tal y como se muestra aquí) o por medio de una biblioteca como [AutoMapper](https://github.com/AutoMapper/AutoMapper).</span><span class="sxs-lookup"><span data-stu-id="2fefd-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="2fefd-162">Estas son las pruebas unitarias de los métodos API `Create` y `ForSession`:</span><span class="sxs-lookup"><span data-stu-id="2fefd-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="2fefd-163">Como se ha indicado anteriormente, si quiere comprobar el comportamiento del método cuando `ModelState` no es válido, agregue un error de modelo al controlador como parte de la prueba.</span><span class="sxs-lookup"><span data-stu-id="2fefd-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="2fefd-164">No intente probar la validación del modelo o el enlace de modelos en las pruebas unitarias: céntrese tan solo en el comportamiento de su método de acción al confrontarlo con un valor de `ModelState` determinado.</span><span class="sxs-lookup"><span data-stu-id="2fefd-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="2fefd-165">La segunda prueba depende de que el repositorio devuelva null, por lo que el repositorio ficticio está configurado para devolver un valor null.</span><span class="sxs-lookup"><span data-stu-id="2fefd-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="2fefd-166">No es necesario crear una base de datos de prueba (en memoria o de cualquier otro modo) ni crear una consulta que devuelva este resultado. Esto se puede realizar en una sola instrucción, tal y como se muestra.</span><span class="sxs-lookup"><span data-stu-id="2fefd-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="2fefd-167">La última prueba confirma que se llama al método `Update` del repositorio.</span><span class="sxs-lookup"><span data-stu-id="2fefd-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="2fefd-168">Tal y como hicimos anteriormente, se llama al objeto ficticio con `Verifiable` y, después, se llama al método `Verify` del repositorio ficticio para confirmar que el método Verifiable se ha ejecutado.</span><span class="sxs-lookup"><span data-stu-id="2fefd-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="2fefd-169">Las pruebas unitarias no se encargan de garantizar que el método `Update` guarda los datos; esto se puede realizar con una prueba de integración.</span><span class="sxs-lookup"><span data-stu-id="2fefd-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="2fefd-170">Pruebas de integración</span><span class="sxs-lookup"><span data-stu-id="2fefd-170">Integration testing</span></span>

<span data-ttu-id="2fefd-171">Las [pruebas de integración](xref:test/integration-tests) se realizan para garantizar que distintos módulos independientes dentro de la aplicación funcionan correctamente juntos.</span><span class="sxs-lookup"><span data-stu-id="2fefd-171">[Integration tests](xref:test/integration-tests) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="2fefd-172">Por lo general, todo lo que se puede comprobar con una prueba unitaria también se puede comprobar con una prueba de integración, pero no a la inversa.</span><span class="sxs-lookup"><span data-stu-id="2fefd-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="2fefd-173">Pero las pruebas de integración suelen ser mucho más lentas que las unitarias.</span><span class="sxs-lookup"><span data-stu-id="2fefd-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="2fefd-174">Por tanto, lo mejor es comprobar todo lo que sea factible con las pruebas unitarias y recurrir a las pruebas de integración en los casos en los que existan varios colaboradores.</span><span class="sxs-lookup"><span data-stu-id="2fefd-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="2fefd-175">Los objetos ficticios rara vez se usan en las pruebas de integración, aunque pueden seguir siendo de utilidad.</span><span class="sxs-lookup"><span data-stu-id="2fefd-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="2fefd-176">En las pruebas unitarias, los objetos ficticios constituyen un método eficaz de controlar el modo en que los colaboradores fuera de la unidad que se está probando deben comportarse según los propósitos de la prueba.</span><span class="sxs-lookup"><span data-stu-id="2fefd-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="2fefd-177">En una prueba de integración se usan colaboradores reales para confirmar que todo el subsistema funciona correctamente en conjunto.</span><span class="sxs-lookup"><span data-stu-id="2fefd-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="2fefd-178">Estado de la aplicación</span><span class="sxs-lookup"><span data-stu-id="2fefd-178">Application state</span></span>

<span data-ttu-id="2fefd-179">Una consideración importante al realizar pruebas de integración es cómo establecer el estado de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="2fefd-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="2fefd-180">Las pruebas se deben ejecutar de manera independiente entre sí, por lo que cada prueba debe comenzar con la aplicación en un estado conocido.</span><span class="sxs-lookup"><span data-stu-id="2fefd-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="2fefd-181">Que la aplicación no use una base de datos o tenga algún tipo de persistencia no debe ser un problema.</span><span class="sxs-lookup"><span data-stu-id="2fefd-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="2fefd-182">Pero la mayoría de las aplicaciones reales almacenan su estado en algún tipo de almacén de datos, de modo que cualquier modificación que se realice a raíz de una prueba puede repercutir en otra, a menos que se restablezca el almacén de datos.</span><span class="sxs-lookup"><span data-stu-id="2fefd-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="2fefd-183">Si se usa el método integrado `TestServer`, será muy fácil hospedar aplicaciones ASP.NET Core en nuestras pruebas de integración, pero esto no da acceso necesariamente a los datos que se van a usar.</span><span class="sxs-lookup"><span data-stu-id="2fefd-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="2fefd-184">Si se usa una base de datos real, un método consiste en conectar la aplicación a una base de datos de prueba, a la que las pruebas pueden obtener acceso, y confirmar que está restablecida en un estado conocido antes de que cada prueba se ejecute.</span><span class="sxs-lookup"><span data-stu-id="2fefd-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="2fefd-185">En esta aplicación de ejemplo, uso la base de datos InMemoryDatabase de Entity Framework Core, por lo que no puedo simplemente conectarme a ella desde mi proyecto de prueba.</span><span class="sxs-lookup"><span data-stu-id="2fefd-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="2fefd-186">En su lugar, expondré un método `InitializeDatabase` desde la clase `Startup` de la aplicación, y llamaré a ese método cuando la aplicación se inicie si está en el entorno `Development`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="2fefd-187">Mis pruebas de integración sacarán partido de esto automáticamente siempre que tengan el entorno establecido en `Development`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="2fefd-188">No tiene que preocuparse de restablecer la base de datos, ya que InMemoryDatabase se restablece cada vez que la aplicación se reinicia.</span><span class="sxs-lookup"><span data-stu-id="2fefd-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="2fefd-189">La clase `Startup`:</span><span class="sxs-lookup"><span data-stu-id="2fefd-189">The `Startup` class:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="2fefd-190">Verá que el método `GetTestSession` se usa con bastante asiduidad en las siguientes pruebas de integración.</span><span class="sxs-lookup"><span data-stu-id="2fefd-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="2fefd-191">Acceso a las vistas</span><span class="sxs-lookup"><span data-stu-id="2fefd-191">Accessing views</span></span>

<span data-ttu-id="2fefd-192">En cada clase de prueba de integración se configura el método `TestServer` que ejecutará la aplicación de ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="2fefd-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="2fefd-193">`TestServer` hospeda la aplicación web de forma predeterminada en la carpeta donde se está ejecutando (en este caso, la carpeta del proyecto de prueba).</span><span class="sxs-lookup"><span data-stu-id="2fefd-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="2fefd-194">Por tanto, si intenta probar las acciones del controlador que devuelven `ViewResult`, es posible que aparezca este error:</span><span class="sxs-lookup"><span data-stu-id="2fefd-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="2fefd-195">Para corregir este problema, debe configurar la raíz del contenido del servidor de forma que pueda localizar las vistas del proyecto que se está comprobando.</span><span class="sxs-lookup"><span data-stu-id="2fefd-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="2fefd-196">Esto se consigue con una llamada a `UseContentRoot` en la clase `TestFixture`, como se aprecia aquí:</span><span class="sxs-lookup"><span data-stu-id="2fefd-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="2fefd-197">La clase `TestFixture` se encarga de configurar y crear el método `TestServer`, que configura un `HttpClient` para comunicarse con dicho método `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="2fefd-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="2fefd-198">En cada una de las pruebas de integración se usa la propiedad `Client` para conectarse al servidor de prueba y realizar una solicitud.</span><span class="sxs-lookup"><span data-stu-id="2fefd-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="2fefd-199">En la primera prueba de arriba, `responseString` contiene el HTML realmente presentado de la vista, que se puede revisar para confirmar que contiene los resultados esperados.</span><span class="sxs-lookup"><span data-stu-id="2fefd-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="2fefd-200">La segunda prueba crea un formulario POST con un nombre de sesión único y lo envía a la aplicación para, seguidamente, confirmar que se devuelve la redirección prevista.</span><span class="sxs-lookup"><span data-stu-id="2fefd-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="2fefd-201">Métodos de API</span><span class="sxs-lookup"><span data-stu-id="2fefd-201">API methods</span></span>

<span data-ttu-id="2fefd-202">Si la aplicación expone API web, conviene confirmar que se ejecutan según lo previsto por medio de pruebas automatizadas.</span><span class="sxs-lookup"><span data-stu-id="2fefd-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="2fefd-203">El método integrado `TestServer` permite comprobar API web de forma muy sencilla.</span><span class="sxs-lookup"><span data-stu-id="2fefd-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="2fefd-204">Si los métodos de API usan el enlace de modelos, deberá comprobar siempre el factor `ModelState.IsValid` y, en este sentido, las pruebas de integración son el lugar adecuado para confirmar que la validación del modelo funciona correctamente.</span><span class="sxs-lookup"><span data-stu-id="2fefd-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="2fefd-205">El siguiente conjunto de pruebas tiene como destino el método `Create` en la clase [IdeasController](xref:mvc/controllers/testing#ideas-controller) de arriba:</span><span class="sxs-lookup"><span data-stu-id="2fefd-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="2fefd-206">A diferencia de las pruebas de integración de acciones que devuelven vistas HTML, los métodos de API web que devuelven resultados se suelen poder deserializar como objetos fuertemente tipados, tal y como arroja la última prueba mostrada arriba.</span><span class="sxs-lookup"><span data-stu-id="2fefd-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="2fefd-207">En este caso, la prueba deserializa el resultado en una instancia de `BrainstormSession` y confirma que la idea se agregó correctamente a la colección de ideas.</span><span class="sxs-lookup"><span data-stu-id="2fefd-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="2fefd-208">En el [proyecto de ejemplo](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample) de este artículo encontrará más ejemplos de pruebas de integración.</span><span class="sxs-lookup"><span data-stu-id="2fefd-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
