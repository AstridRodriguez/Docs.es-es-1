---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Entender y controlar eventos de duración de la conexión en SignalR | Microsoft Docs
author: pfletcher
description: En este artículo se describe cómo utilizar los eventos expuestos por la API Hubs.
ms.author: riande
ms.date: 06/10/2014
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 1783a3ab292a5460d5cc1b7ad78073071d65d379
ms.sourcegitcommit: a4dcca4f1cb81227c5ed3c92dc0e28be6e99447b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/10/2018
ms.locfileid: "48911961"
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="eef3f-103">Entender y controlar eventos de duración de la conexión en SignalR</span><span class="sxs-lookup"><span data-stu-id="eef3f-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="eef3f-104">por [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="eef3f-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="eef3f-105">En este artículo se proporciona información general de los eventos de conexión, la reconexión y la desconexión de SignalR que se pueden controlar y la configuración de tiempo de espera y keepalive que puede configurar.</span><span class="sxs-lookup"><span data-stu-id="eef3f-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="eef3f-106">Este artículo se supone que ya tiene algunos conocimientos de eventos de duración de la conexión y SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="eef3f-107">Para obtener una introducción a SignalR, consulte [Introducción a SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="eef3f-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="eef3f-108">Para las listas de eventos de duración de la conexión, consulte los siguientes recursos:</span><span class="sxs-lookup"><span data-stu-id="eef3f-108">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="eef3f-109">Cómo controlar eventos de duración de la conexión en la clase Hub</span><span class="sxs-lookup"><span data-stu-id="eef3f-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="eef3f-110">Cómo controlar eventos de duración de la conexión en los clientes de JavaScript</span><span class="sxs-lookup"><span data-stu-id="eef3f-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="eef3f-111">Cómo controlar eventos de duración de la conexión en los clientes de .NET</span><span class="sxs-lookup"><span data-stu-id="eef3f-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="eef3f-112">Versiones de software que se usa en este tema</span><span class="sxs-lookup"><span data-stu-id="eef3f-112">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="eef3f-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="eef3f-113">Visual Studio 2013</span></span>](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - <span data-ttu-id="eef3f-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="eef3f-114">.NET 4.5</span></span>
> - <span data-ttu-id="eef3f-115">Versión 2 de SignalR</span><span class="sxs-lookup"><span data-stu-id="eef3f-115">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="eef3f-116">Versiones anteriores de este tema.</span><span class="sxs-lookup"><span data-stu-id="eef3f-116">Previous versions of this topic</span></span>
>
> <span data-ttu-id="eef3f-117">Para obtener información acerca de las versiones anteriores de SignalR, consulte [versiones anteriores de SignalR](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="eef3f-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="eef3f-118">Preguntas y comentarios</span><span class="sxs-lookup"><span data-stu-id="eef3f-118">Questions and comments</span></span>
>
> <span data-ttu-id="eef3f-119">Deje comentarios sobre cómo le gustó de este tutorial y que podíamos mejorar en los comentarios en la parte inferior de la página.</span><span class="sxs-lookup"><span data-stu-id="eef3f-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="eef3f-120">Si tiene preguntas que no están directamente relacionados con el tutorial, puede publicarlos en el [foro de ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) o [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="eef3f-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="eef3f-121">Información general</span><span class="sxs-lookup"><span data-stu-id="eef3f-121">Overview</span></span>

<span data-ttu-id="eef3f-122">Este artículo contiene las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="eef3f-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="eef3f-123">Escenarios y la terminología de duración de conexión</span><span class="sxs-lookup"><span data-stu-id="eef3f-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="eef3f-124">Las conexiones de SignalR, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="eef3f-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="eef3f-125">Escenarios de desconexión del transporte</span><span class="sxs-lookup"><span data-stu-id="eef3f-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="eef3f-126">Escenarios de desconexión del cliente</span><span class="sxs-lookup"><span data-stu-id="eef3f-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="eef3f-127">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="eef3f-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="eef3f-128">Configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="eef3f-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="eef3f-129">Valor de ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="eef3f-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="eef3f-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="eef3f-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="eef3f-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="eef3f-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="eef3f-132">Cómo cambiar la configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="eef3f-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="eef3f-133">Cómo notificar al usuario acerca de las desconexiones</span><span class="sxs-lookup"><span data-stu-id="eef3f-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="eef3f-134">Cómo volver a conectar de forma continua</span><span class="sxs-lookup"><span data-stu-id="eef3f-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="eef3f-135">Cómo desconectar a un cliente en el código de servidor</span><span class="sxs-lookup"><span data-stu-id="eef3f-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="eef3f-136">Detectar el motivo de una desconexión</span><span class="sxs-lookup"><span data-stu-id="eef3f-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="eef3f-137">Son vínculos a temas de referencia de API a la versión 4.5 de .NET de la API.</span><span class="sxs-lookup"><span data-stu-id="eef3f-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="eef3f-138">Si usa .NET 4, consulte [la versión 4 de .NET de los temas de la API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="eef3f-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="eef3f-139">Escenarios y la terminología de duración de conexión</span><span class="sxs-lookup"><span data-stu-id="eef3f-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="eef3f-140">El `OnReconnected` puede ejecutar el controlador de eventos en un concentrador SignalR directamente después `OnConnected` pero no después `OnDisconnected` de un cliente determinado.</span><span class="sxs-lookup"><span data-stu-id="eef3f-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="eef3f-141">El motivo que puede tener una reconexión sin una desconexión es que hay varias maneras en que se utiliza la palabra "conexión" en SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="eef3f-142">Las conexiones de SignalR, conexiones de transporte y conexiones físicas</span><span class="sxs-lookup"><span data-stu-id="eef3f-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="eef3f-143">En este artículo se diferencia entre *conexiones SignalR*, *las conexiones de transporte*, y *conexiones físicas*:</span><span class="sxs-lookup"><span data-stu-id="eef3f-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="eef3f-144">**Conexión de SignalR** hace referencia a una relación lógica entre un cliente y una dirección URL del servidor, mantenida por la API SignalR y se identifica mediante un identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="eef3f-145">Los datos acerca de esta relación es mantenidos por SignalR y se utilizan para establecer una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="eef3f-146">Los extremos de la relación y SignalR se deshace de los datos cuando el cliente llama a la `Stop` se llega a método o un límite de tiempo de espera mientras se está intentando volver a establecer una conexión de transporte pierde SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="eef3f-147">**Conexión de transporte** hace referencia a una relación lógica entre un cliente y un servidor, mantenido por una de las API de transporte cuatro: WebSockets, eventos de servidor envió enmarcar indefinidamente o largos de sondeo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="eef3f-148">SignalR usa la API de transporte para crear una conexión de transporte y la API de transporte depende de la existencia de una conexión de red físico para crear la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="eef3f-149">La conexión de transporte finaliza cuando termina de SignalR, o cuando el transporte API detecta que se ha interrumpido la conexión física.</span><span class="sxs-lookup"><span data-stu-id="eef3f-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="eef3f-150">**Conexión física** hace referencia a los vínculos de red físico, cables, las señales inalámbricas, enrutadores, etc., que facilitan la comunicación entre un equipo cliente y un equipo de servidor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="eef3f-151">La conexión física debe estar presente con el fin de establecer una conexión de transporte, y se debe establecer una conexión de transporte con el fin de establecer una conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="eef3f-152">Sin embargo, interrumpir la conexión física no siempre finalizar inmediatamente la conexión de transporte o la conexión de SignalR, como se explicará más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="eef3f-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="eef3f-153">En el diagrama siguiente, la conexión de SignalR está representada por la API Hubs y la capa PersistentConnection API SignalR, la conexión de transporte se representa mediante la capa de transporte y la conexión física es representada por las líneas entre el servidor y los clientes.</span><span class="sxs-lookup"><span data-stu-id="eef3f-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagrama de arquitectura de SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="eef3f-155">Cuando se llama a la `Start` método en un cliente de SignalR, se proporciona código de cliente de SignalR con toda la información que necesita con el fin de establecer una conexión a un servidor física.</span><span class="sxs-lookup"><span data-stu-id="eef3f-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="eef3f-156">Código de cliente de SignalR usa esta información para realizar una solicitud HTTP y establecer una conexión física que usa uno de los métodos de transporte de cuatro.</span><span class="sxs-lookup"><span data-stu-id="eef3f-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="eef3f-157">Si se produce un error en la conexión de transporte o se produce un error en el servidor, la conexión de SignalR no desaparezcan inmediatamente porque el cliente todavía tiene la información que necesita para volver a establecer automáticamente una nueva conexión de transporte con la misma dirección URL de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="eef3f-158">En este escenario, no está implicada ninguna intervención de la aplicación de usuario y, cuando el código de cliente de SignalR establece una nueva conexión de transporte, no se inicia una nueva conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="eef3f-159">La continuidad de la conexión de SignalR se refleja en el hecho de que el identificador de conexión, que se crea cuando se llama a la `Start` , el método no cambia.</span><span class="sxs-lookup"><span data-stu-id="eef3f-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="eef3f-160">El `OnReconnected` controlador de eventos en el concentrador se ejecuta cuando una conexión de transporte se restablece automáticamente después de haberse perdido.</span><span class="sxs-lookup"><span data-stu-id="eef3f-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="eef3f-161">El `OnDisconnected` ejecuta el controlador de eventos al final de una conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="eef3f-162">Puede finalizar una conexión de SignalR en cualquiera de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="eef3f-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="eef3f-163">Si el cliente llama a la `Stop` método, se envía un mensaje de detención al servidor y cliente y servidor de terminan inmediatamente la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="eef3f-164">Después de que se pierde la conectividad entre cliente y servidor, el cliente intenta volver a conectar y el servidor espera a que el cliente volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="eef3f-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="eef3f-165">Si intenta volver a conectarse no tiene éxito y finaliza el período de tiempo de espera de desconexión, cliente y servidor de terminar la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="eef3f-166">El cliente deja de intentar volver a conectar y el servidor elimina de su representación de la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="eef3f-167">Si el cliente deja de ejecutarse sin tener una oportunidad para llamar a la `Stop` método, el servidor espera a que el cliente puede volver a conectar y, a continuación, finaliza la conexión de SignalR tras el período de tiempo de espera de desconexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="eef3f-168">Si el servidor deja de ejecutar, el cliente intenta volver a conectar (volver a crea la conexión de transporte) y, a continuación, finaliza la conexión de SignalR tras el período de tiempo de espera de desconexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="eef3f-169">Cuando no hay ningún problema de conexión y la aplicación de usuario finaliza la conexión de SignalR mediante una llamada a la `Stop` método, la conexión de SignalR y la conexión de transporte empiezan y terminan en aproximadamente al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="eef3f-170">Las secciones siguientes describen con más detalle los otros escenarios.</span><span class="sxs-lookup"><span data-stu-id="eef3f-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="eef3f-171">Escenarios de desconexión del transporte</span><span class="sxs-lookup"><span data-stu-id="eef3f-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="eef3f-172">Conexiones físicas podrían ser lentas o podría haber interrupciones en la conectividad.</span><span class="sxs-lookup"><span data-stu-id="eef3f-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="eef3f-173">Dependiendo de factores como la longitud de la interrupción, se puede quitar la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="eef3f-174">SignalR, a continuación, intenta volver a establecer la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="eef3f-175">En ocasiones la conexión de transporte API detecta la interrupción y quita la conexión de transporte, y SignalR descubre inmediatamente que se pierde la conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="eef3f-176">En otros escenarios, ni la API de conexión de transporte ni SignalR se da cuenta inmediatamente que se perdió la conectividad.</span><span class="sxs-lookup"><span data-stu-id="eef3f-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="eef3f-177">Para todos los transportes, excepto el sondeo largo, el cliente de SignalR usa una función denominada *keepalive* para comprobar si la pérdida de conectividad que la API de transporte no puede detectar.</span><span class="sxs-lookup"><span data-stu-id="eef3f-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="eef3f-178">Para obtener información acerca de conexiones de sondeo largo, consulte [tiempo de espera y keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="eef3f-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="eef3f-179">Cuando una conexión está inactiva, periódicamente el servidor envía un paquete keepalive al cliente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="eef3f-180">A partir de la fecha en que se escribe este artículo, la frecuencia predeterminada es cada 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="eef3f-181">Realizando escuchas para estos paquetes, pueden indicar a los clientes si hay un problema de conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="eef3f-182">Si no se recibe un paquete keepalive cuando se esperaba, poco después el cliente asume que hay problemas de conexión, como lentitud o interrupciones.</span><span class="sxs-lookup"><span data-stu-id="eef3f-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="eef3f-183">Si el keepalive todavía no se recibe después de un tiempo más largo, el cliente supone que se quitó la conexión y comienza a intentar la reconexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="eef3f-184">El diagrama siguiente muestra los eventos de cliente y servidor que se generan en un escenario típico cuando hay problemas con la conexión física que no se reconocen inmediatamente por la API de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="eef3f-185">El diagrama se aplica a las siguientes circunstancias:</span><span class="sxs-lookup"><span data-stu-id="eef3f-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="eef3f-186">El transporte es WebSockets, marco indefinidamente o eventos enviados por el servidor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="eef3f-187">Hay distintos períodos de interrupción en la conexión de red física.</span><span class="sxs-lookup"><span data-stu-id="eef3f-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="eef3f-188">La API de transporte no conocen la existencia de las interrupciones, por lo que SignalR se basa en la funcionalidad de keepalive detectarlos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Desconexiones de transporte](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="eef3f-190">Si el cliente pasa a volver a conectar el modo pero no puede establecer una conexión de transporte dentro del límite de tiempo de espera de desconexión, el servidor finaliza la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="eef3f-191">Cuando esto ocurre, el servidor ejecuta el centro `OnDisconnected` método y pone en cola un mensaje de desconexión para enviar al cliente en caso de que el cliente se administra a conectarse más tarde.</span><span class="sxs-lookup"><span data-stu-id="eef3f-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="eef3f-192">Si el cliente, a continuación, volver a conectar, recibe el comando de desconexión y llama el `Stop` método.</span><span class="sxs-lookup"><span data-stu-id="eef3f-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="eef3f-193">En este escenario, `OnReconnected` no se ejecuta cuando se vuelve a conectar el cliente, y `OnDisconnected` no se ejecuta cuando el cliente llama a `Stop`.</span><span class="sxs-lookup"><span data-stu-id="eef3f-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="eef3f-194">El siguiente diagrama muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="eef3f-194">The following diagram illustrates this scenario.</span></span>

![Interrupciones de transporte - tiempo de espera del servidor](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="eef3f-196">Los eventos de duración de conexión de SignalR que se generen en el cliente son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="eef3f-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="eef3f-197">`ConnectionSlow` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="eef3f-198">Se genera cuando una proporción del período de tiempo de espera de keepalive preestablecida ha transcurrido desde el último mensaje o keepalive ping se recibió.</span><span class="sxs-lookup"><span data-stu-id="eef3f-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="eef3f-199">El período de advertencia de tiempo de espera de keepalive predeterminado es 2/3 del tiempo de espera keepalive.</span><span class="sxs-lookup"><span data-stu-id="eef3f-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="eef3f-200">El tiempo de espera de keepalive es 20 segundos, por lo que se produce la advertencia a los 13 segundos aproximadamente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="eef3f-201">De forma predeterminada, el servidor envía pings keepalive cada 10 segundos y el cliente comprueba si keepalive pings sobre cada 2 segundos (un tercio de la diferencia entre el valor de tiempo de espera de conexión abierta y el valor de advertencia de tiempo de espera de keepalive).</span><span class="sxs-lookup"><span data-stu-id="eef3f-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="eef3f-202">Si el transporte API deja de tener en cuenta una desconexión, SignalR podría informar de la desconexión antes de que pase el período de advertencia de tiempo de espera de keepalive.</span><span class="sxs-lookup"><span data-stu-id="eef3f-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="eef3f-203">En ese caso, el `ConnectionSlow` no se provocaría el evento, y SignalR podría ir directamente a la `Reconnecting` eventos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="eef3f-204">`Reconnecting` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="eef3f-205">Se genera cuando (a) el transporte API detecta que se pierde la conexión, o (b) el período de tiempo de espera de keepalive ha transcurrido desde el último mensaje o keepalive ping se recibió.</span><span class="sxs-lookup"><span data-stu-id="eef3f-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="eef3f-206">El código de cliente de SignalR empieza a intentar volver a conectarse.</span><span class="sxs-lookup"><span data-stu-id="eef3f-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="eef3f-207">Puede controlar este evento si desea que la aplicación para realizar alguna acción cuando se pierde una conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="eef3f-208">Actualmente, el período de tiempo de espera predeterminado keepalive es 20 segundos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="eef3f-209">Si el código de cliente intenta llamar a un método de concentrador mientras SignalR está en volver a conectarse de modo, SignalR intentará enviar el comando.</span><span class="sxs-lookup"><span data-stu-id="eef3f-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="eef3f-210">La mayoría de los casos, estos intentos se producirá un error, pero en algunos casos podría realizarse correctamente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="eef3f-211">Para los eventos enviados por el servidor, siempre el marco y transportes de sondeo largo, SignalR usa dos canales de comunicación, uno que utiliza el cliente para enviar mensajes y otro que usa para recibir mensajes.</span><span class="sxs-lookup"><span data-stu-id="eef3f-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="eef3f-212">El canal usado para la recepción es el permanentemente abierta y que es lo que se cierra cuando se interrumpe la conexión física.</span><span class="sxs-lookup"><span data-stu-id="eef3f-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="eef3f-213">El canal que se utiliza para enviar sigue estando disponible, por lo que si se restaura la conectividad física, una llamada de método de cliente al servidor puede ser satisfactoria antes de que se restablezca el canal de recepción.</span><span class="sxs-lookup"><span data-stu-id="eef3f-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="eef3f-214">El valor devuelto podría no recibir hasta SignalR vuelve a abre el canal usado para la recepción.</span><span class="sxs-lookup"><span data-stu-id="eef3f-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="eef3f-215">`Reconnected` evento de cliente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="eef3f-216">Se genera cuando se restablece la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="eef3f-217">El `OnReconnected` ejecuta el controlador de eventos en el concentrador.</span><span class="sxs-lookup"><span data-stu-id="eef3f-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="eef3f-218">`Closed` evento de cliente (`disconnected` eventos en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eef3f-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="eef3f-219">Se produce cuando expira el período de tiempo de espera de desconexión mientras el código de cliente de SignalR está intentando volver a conectarse después de perder la conexión de transporte.</span><span class="sxs-lookup"><span data-stu-id="eef3f-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="eef3f-220">Desconecte el valor predeterminado es de 30 segundos de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="eef3f-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="eef3f-221">(También se genera este evento cuando la conexión finaliza debido a que el `Stop` se llama al método.)</span><span class="sxs-lookup"><span data-stu-id="eef3f-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="eef3f-222">Las interrupciones de la conexión de transporte que no se detectan mediante la API de transporte y no retrasar la recepción de keepalive pings desde el servidor durante más tiempo que el período de advertencia de tiempo de espera de keepalive quizás no provoque cualquier conexión que se generen eventos de duración.</span><span class="sxs-lookup"><span data-stu-id="eef3f-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="eef3f-223">Algunos entornos de red deliberadamente cerrar las conexiones inactivas y otra función de los paquetes keepalive es ayudar a evitar que esto al permitir que estas redes se sabe que una conexión de SignalR está en uso.</span><span class="sxs-lookup"><span data-stu-id="eef3f-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="eef3f-224">En casos extremos la frecuencia predeterminada de pings keepalive no podría ser suficiente para impedir las conexiones cerradas.</span><span class="sxs-lookup"><span data-stu-id="eef3f-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="eef3f-225">En ese caso puede configurar keepalive pings se envíen con más frecuencia.</span><span class="sxs-lookup"><span data-stu-id="eef3f-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="eef3f-226">Para obtener más información, consulte [tiempo de espera y keepalive](#timeoutkeepalive) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="eef3f-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="eef3f-227">**Importante**: no se garantiza que la secuencia de eventos que se describen aquí.</span><span class="sxs-lookup"><span data-stu-id="eef3f-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="eef3f-228">SignalR realiza todos los intentos para provocar eventos de duración de la conexión de una manera predecible según este esquema, pero existen muchas variaciones de eventos de la red y de muchas maneras en que los marcos de comunicaciones subyacente como las API de transporte de controlan.</span><span class="sxs-lookup"><span data-stu-id="eef3f-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="eef3f-229">Por ejemplo, el `Reconnected` no es posible que se produce el evento cuando se vuelve a conectar el cliente, o la `OnConnected` controlador en el servidor puede ejecutar si el intento para establecer una conexión es incorrecto.</span><span class="sxs-lookup"><span data-stu-id="eef3f-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="eef3f-230">Este tema describe únicamente los efectos que normalmente se generarían en determinadas circunstancias típicas.</span><span class="sxs-lookup"><span data-stu-id="eef3f-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="eef3f-231">Escenarios de desconexión del cliente</span><span class="sxs-lookup"><span data-stu-id="eef3f-231">Client disconnection scenarios</span></span>

<span data-ttu-id="eef3f-232">En un explorador del cliente, el código de cliente de SignalR que mantiene una conexión SignalR se ejecuta en el contexto de JavaScript de una página web.</span><span class="sxs-lookup"><span data-stu-id="eef3f-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="eef3f-233">Que ha razón por la conexión de SignalR tiene que finalizar cuando se navega desde una página a otra y ese por qué tiene varias conexiones con varios identificadores de conexión si se conecta desde varias ventanas del explorador o tabulaciones.</span><span class="sxs-lookup"><span data-stu-id="eef3f-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="eef3f-234">Cuando el usuario cierra una ventana o ficha, o navega a una página nueva o actualiza la página, la conexión de SignalR finaliza inmediatamente porque el código de cliente de SignalR controla ese evento de explorador para llamadas y el `Stop` método.</span><span class="sxs-lookup"><span data-stu-id="eef3f-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="eef3f-235">En estos escenarios, o en cualquier plataforma de cliente cuando la aplicación llama a la `Stop` método, el `OnDisconnected` controlador de eventos que se ejecuta inmediatamente en el servidor y el cliente genera el `Closed` evento (el evento se denomina `disconnected` en JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eef3f-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="eef3f-236">Si una aplicación cliente o el equipo que se está ejecutando en se bloquea o se suspende (por ejemplo, cuando el usuario cierra el equipo portátil), el servidor no se informa sobre lo que sucedió.</span><span class="sxs-lookup"><span data-stu-id="eef3f-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="eef3f-237">Como sabe que el servidor, la pérdida del cliente podría ser debido a interrupciones de conectividad y el cliente podría estar intentando volver a conectar.</span><span class="sxs-lookup"><span data-stu-id="eef3f-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="eef3f-238">Por lo tanto, en estos casos el servidor espera para dar al cliente una oportunidad de volver a conectar, y `OnDisconnected` no se ejecuta hasta que el período de tiempo de espera de desconexión expire (aproximadamente 30 segundos de forma predeterminada).</span><span class="sxs-lookup"><span data-stu-id="eef3f-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="eef3f-239">El siguiente diagrama muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="eef3f-239">The following diagram illustrates this scenario.</span></span>

![Error en el equipo cliente](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="eef3f-241">Escenarios de desconexión del servidor</span><span class="sxs-lookup"><span data-stu-id="eef3f-241">Server disconnection scenarios</span></span>

<span data-ttu-id="eef3f-242">Cuando un servidor se queda sin conexión, se reinicia, se produce un error, el dominio de aplicación recicla, etc., el resultado puede ser similar a una pérdida de conexión o el transporte de API y SignalR podrían saber de inmediato que el servidor ha desaparecido y SignalR podría comenzar intentando volver a conectar sin generar el `ConnectionSlow` eventos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="eef3f-243">Si el cliente entra en volver a conectar el modo y si el servidor recupera o se reinicia o un nuevo servidor se pone en línea antes de que expire el período de tiempo de espera de desconexión, el cliente se volverá a conectar al servidor nuevo o restaurado.</span><span class="sxs-lookup"><span data-stu-id="eef3f-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="eef3f-244">En ese caso, la conexión de SignalR continúa en el cliente y el `Reconnected` provoca el evento.</span><span class="sxs-lookup"><span data-stu-id="eef3f-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="eef3f-245">En el primer servidor, `OnDisconnected` nunca se ejecuta y en el nuevo servidor, `OnReconnected` se ejecuta aunque `OnConnected` nunca se ejecutó para el cliente en ese servidor antes.</span><span class="sxs-lookup"><span data-stu-id="eef3f-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="eef3f-246">(El efecto es el mismo si el cliente se vuelve a conectar al mismo servidor después de un reciclaje del dominio de aplicación o reiniciar el equipo, porque cuando reinicia el servidor no tiene memoria de la actividad de conexión anterior). El diagrama siguiente se da por supuesto que la API de transporte se da cuenta pierde la conexión inmediatamente, por lo que el `ConnectionSlow` no se produce el evento.</span><span class="sxs-lookup"><span data-stu-id="eef3f-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Error del servidor y reconexión](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="eef3f-248">Si un servidor no está disponible dentro del período de tiempo de espera de desconexión, finaliza la conexión de SignalR.</span><span class="sxs-lookup"><span data-stu-id="eef3f-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="eef3f-249">En este escenario, el `Closed` eventos (`disconnected` en clientes de JavaScript) se genera en el cliente pero `OnDisconnected` nunca se llama en el servidor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="eef3f-250">El diagrama siguiente se da por supuesto que la API de transporte no conocen la existencia de la conexión perdida, por lo que se detecta mediante la funcionalidad de SignalR keepalive y `ConnectionSlow` provoca el evento.</span><span class="sxs-lookup"><span data-stu-id="eef3f-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Tiempo de espera y errores de servidor](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="eef3f-252">Configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="eef3f-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="eef3f-253">El valor predeterminado `ConnectionTimeout`, `DisconnectTimeout`, y `KeepAlive` valores son adecuados para la mayoría de los escenarios, pero puede cambiarse si el entorno tiene necesidades especiales.</span><span class="sxs-lookup"><span data-stu-id="eef3f-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="eef3f-254">Por ejemplo, si su entorno de red cierra las conexiones que están inactivas durante 5 segundos, tendrá que disminuya el valor keepalive.</span><span class="sxs-lookup"><span data-stu-id="eef3f-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="eef3f-255">Valor de ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="eef3f-255">ConnectionTimeout</span></span>

<span data-ttu-id="eef3f-256">Esta configuración representa la cantidad de tiempo que una conexión de transporte abiertos y esperando una respuesta antes de cerrarla y abrir una nueva conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="eef3f-257">El valor predeterminado es de 110 segundos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="eef3f-258">Esta configuración aplica solo cuando la funcionalidad keepalive está deshabilitada, que normalmente se aplica solo a la larga transporte de sondeo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="eef3f-259">El siguiente diagrama ilustra el efecto de esta configuración en un valor largo conexión de transporte de sondeo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Conexión de transporte de sondeo largo](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="eef3f-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="eef3f-261">DisconnectTimeout</span></span>

<span data-ttu-id="eef3f-262">Esta configuración representa la cantidad de tiempo de espera después de que se pierde una conexión de transporte antes de generar el `Disconnected` eventos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="eef3f-263">El valor predeterminado es 30 segundos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-263">The default value is 30 seconds.</span></span> <span data-ttu-id="eef3f-264">Al establecer `DisconnectTimeout`, `KeepAlive` se establece automáticamente en 1/3 de la `DisconnectTimeout` valor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="eef3f-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="eef3f-265">KeepAlive</span></span>

<span data-ttu-id="eef3f-266">Esta configuración representa la cantidad de tiempo de espera antes de enviar un paquete keepalive a través de una conexión inactiva.</span><span class="sxs-lookup"><span data-stu-id="eef3f-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="eef3f-267">El valor predeterminado es 10 segundos.</span><span class="sxs-lookup"><span data-stu-id="eef3f-267">The default value is 10 seconds.</span></span> <span data-ttu-id="eef3f-268">Este valor no debe tener más de 1/3 de la `DisconnectTimeout` valor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="eef3f-269">Si desea establecer `DisconnectTimeout` y `KeepAlive`, establezca `KeepAlive` después `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="eef3f-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="eef3f-270">En caso contrario, su `KeepAlive` configuración se sobrescribirá al `DisconnectTimeout` establece automáticamente `KeepAlive` a 1/3 del valor de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="eef3f-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="eef3f-271">Si desea deshabilitar la funcionalidad de keepalive, establezca `KeepAlive` en null.</span><span class="sxs-lookup"><span data-stu-id="eef3f-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="eef3f-272">KeepAlive funcionalidad se deshabilita automáticamente para la larga transporte de sondeo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="eef3f-273">Cómo cambiar la configuración de tiempo de espera y keepalive</span><span class="sxs-lookup"><span data-stu-id="eef3f-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="eef3f-274">Para cambiar los valores predeterminados para estos valores, establecerlos en `Application_Start` en su *Global.asax* de archivos, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="eef3f-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="eef3f-275">Los valores mostrados en el código de ejemplo son el mismo que los valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="eef3f-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="eef3f-276">Cómo notificar al usuario acerca de las desconexiones</span><span class="sxs-lookup"><span data-stu-id="eef3f-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="eef3f-277">En algunas aplicaciones puede mostrar un mensaje al usuario cuando hay problemas de conectividad.</span><span class="sxs-lookup"><span data-stu-id="eef3f-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="eef3f-278">Tiene varias opciones sobre cómo y cuándo deben hacerlo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="eef3f-279">Ejemplos de código siguientes son para un cliente de JavaScript mediante el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="eef3f-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="eef3f-280">Controlar la `connectionSlow` eventos para mostrar un mensaje en cuanto SignalR es consciente de los problemas de conexión, antes de enviarlos a volver a conectarse de modo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="eef3f-281">Controlar la `reconnecting` eventos que se muestra un mensaje cuando SignalR es compatible con una desconexión y se va a volver a conectarse de modo.</span><span class="sxs-lookup"><span data-stu-id="eef3f-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="eef3f-282">Controlar la `disconnected` ha agotado el evento que se muestre un mensaje cuando se intenta volver a conectarse. En este escenario, la única forma de volver a establecer una conexión con el servidor nuevo es reiniciar la conexión de SignalR mediante una llamada a la `Start` método, que creará un nuevo identificador de conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="eef3f-283">Ejemplo de código siguiente utiliza una marca para asegurarse de que emitir la notificación solo después de un tiempo de espera de reconexión, no después de una finalización normal a la conexión de SignalR causada por una llamada a la `Stop` método.</span><span class="sxs-lookup"><span data-stu-id="eef3f-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="eef3f-284">Cómo volver a conectar de forma continua</span><span class="sxs-lookup"><span data-stu-id="eef3f-284">How to continuously reconnect</span></span>

<span data-ttu-id="eef3f-285">En algunas aplicaciones puede volver a establecer automáticamente una conexión después de que se ha perdido y se ha agotado el intento de reconexión. Para ello, puede llamar a la `Start` método desde su `Closed` controlador de eventos (`disconnected` controlador de eventos en los clientes de JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eef3f-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="eef3f-286">Es posible que desee esperar un período de tiempo antes de llamar a `Start` con el fin de evitar hacerlo demasiado con frecuencia cuando el servidor o la conexión física no estén disponibles.</span><span class="sxs-lookup"><span data-stu-id="eef3f-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="eef3f-287">Ejemplo de código siguiente es para un cliente de JavaScript mediante el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="eef3f-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="eef3f-288">Un posible problema de tener en cuenta en los clientes móviles es que los intentos de reconexión continua cuando la conexión física o el servidor no está disponible podrían producir purga innecesarios de la batería.</span><span class="sxs-lookup"><span data-stu-id="eef3f-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="eef3f-289">Cómo desconectar a un cliente en el código de servidor</span><span class="sxs-lookup"><span data-stu-id="eef3f-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="eef3f-290">SignalR versión 2 no tiene una API de servidor integrada para se desconectan los clientes.</span><span class="sxs-lookup"><span data-stu-id="eef3f-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="eef3f-291">Hay [planes para agregar esta funcionalidad en el futuro](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="eef3f-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="eef3f-292">En la versión actual de SignalR, la manera más sencilla para desconectar a un cliente desde el servidor es implementar un método de desconexión del cliente y llamar a ese método desde el servidor.</span><span class="sxs-lookup"><span data-stu-id="eef3f-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="eef3f-293">Ejemplo de código siguiente muestra un método de desconexión de un cliente de JavaScript mediante el proxy generado.</span><span class="sxs-lookup"><span data-stu-id="eef3f-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="eef3f-294">Seguridad: este método para que se desconectan los clientes ni a la API integrada propuesta abordará el escenario de pirateados clientes que ejecutan código malintencionado, ya que podrían volver a conectar los clientes o el código pirateado podría quitar el `stopClient` método o cambio lo que hace.</span><span class="sxs-lookup"><span data-stu-id="eef3f-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="eef3f-295">El lugar adecuado para implementar la protección de estado de denegación de servicio (DOS) no está en el marco de trabajo o la capa del servidor, sino en su lugar en la infraestructura de front-end.</span><span class="sxs-lookup"><span data-stu-id="eef3f-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="eef3f-296">Detectar el motivo de una desconexión</span><span class="sxs-lookup"><span data-stu-id="eef3f-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="eef3f-297">2.1 SignalR agrega una sobrecarga en el servidor `OnDisconnect` evento que indica si el cliente se desconectó deliberadamente en lugar de tiempo de espera. El `StopCalled` del parámetro es true si el cliente cierra explícitamente la conexión.</span><span class="sxs-lookup"><span data-stu-id="eef3f-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="eef3f-298">En JavaScript, si un error de servidor liderado el cliente para desconectarse, la información de error se pasará al cliente como `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="eef3f-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="eef3f-299">**Código de servidor de C#: `stopCalled` parámetro**</span><span class="sxs-lookup"><span data-stu-id="eef3f-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="eef3f-300">**Código de cliente de JavaScript: acceso a `lastError` en el `disconnect` eventos.**</span><span class="sxs-lookup"><span data-stu-id="eef3f-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
